# TSO500 variant annotation and filtration pipeline

This Bash script automates VCF processing from hg19/GRCh37, including LiftOver, VEP and OncoKB annotation, and the generation of a final table filtered by specific transcripts.

## üöÄ Overview of the Workflow

The script iterates through all compressed VCF files (`.vcf.gz`) located in the `./OriginalVcf` directory and performs the following major steps for each sample:

* **Filtering:** Keeps only variants marked as `PASS`.
* **LiftOver:** Converts genomic coordinates from **hg19** to **hg38**.
* **VEP Annotation:** Adds comprehensive functional and clinical annotations.
* **OncoKB Annotation:** Incorporates therapeutically relevant annotations.
* **Table Generation:** Converts the final annotated VCF into a readable CSV table.
* **Summary:** Tracks variant counts at each stage. Usefull while development to see is variants are missed in the previous steps.

## üõ†Ô∏è Prerequisites and Dependencies

This pipeline relies heavily on containerization and specific tools. Ensure you have the following installed and configured:

1.  **Apptainer/Singularity:** Used to run tools like `bcftools` and GATK in containers.
2.  **GATK (v4.6.0.0 or later):** Used for the LiftOver step (run via Apptainer).
3.  **VEP (Variant Effect Predictor):** Installed locally with necessary plugins (SpliceAI, REVEL) and custom databases (ClinVar, CIViC, CancerHotspots).
4.  **Custom Python Scripts:**
    * `oncoKB-API.py`: For communicating with the OncoKB API and annotating the VCF.
    * `vcf2table.py`: For parsing the final VCF and generating a CSV table, using a transcript list (`TSO500_transcripts_list.txt`).
5.  **Reference Files:**
    * **Chain File:** `hg19ToHg38.over.chain` for LiftOver.
    * **Reference Genome:** `hg38.fa` (FASTA format).

## üìÇ Directory Structure

The script is configured to use the following structure. It will automatically create the necessary output directories:

| Directory | Purpose |
| :--- | :--- |
| `./OriginalVcf` | **Input directory.** Contains the initial VCF files (`*.vcf.gz`). |
| `./FilteredVcf` | VCF files after filtering for `PASS` variants. |
| `./LiftOverVcf` | VCF files with coordinates lifted from hg19 to hg38. |
| `./LiftOverVcf/Rejected` | VCF files containing variants that failed the LiftOver step. |
| `./AnnotatedVcf` | VCF files after comprehensive VEP annotation. |
| `./OncoKB_VCF` | Final VCF files after OncoKB clinical annotation. |
| `./Table` | Final output CSV tables generated by `vcf2table.py`. |
| `./Stats` | Directory for variant count statistics, resulting in `variant_counts.txt`. |

> **Note on Reference Files Source:**
> * **Chain File (`hg19ToHg38.over.chain`):** Sourced from UCSC.
    >    **Download URL:** `https://hgdownload.soe.ucsc.edu/goldenPath/hg19/liftOver/hg19ToHg38.over.chain.gz`
> * **Reference Genome (`hg38.fa`):** The GRCh38 reference genome FASTA used in this pipeline was sourced from NCBI and corresponds to the **GRCh38 analysis set** (with alternate contigs masked and the decoy sequence included).
    >    **Download URL:** `https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/000/001/405/GCF_000001405.40_GRCh38.p14/GRCh38_major_release_seqs_for_alignment_pipelines/GCA_000001405.15_GRCh38_no_alt_plus_hs38d1_analysis_set.fna.gz`

‚ùå ***Mani, can you please check I am taking the right genome reference in the liftover and annotation.***

## ‚öôÔ∏è Running the Pipeline

### 1. Setup

* Place your input VCF files (named `D21_11111_22222_Breast_33333_S1.dragen.concat_snv_sv.vcfz`) into the `./OriginalVcf` directory.
* Ensure the required chain file and reference FASTA are correctly specified by the `CHAIN` and `REF` variables.
* Verify the paths to VEP, its caches, plugins, and custom databases are correct.
* Ensure `oncoKB-API.py` and `vcf2table.py` are in the same directory as the pipeline script.
* The pipeline relies on several Python libraries, executed via the scripts `oncoKB-API.py` and `vcf2table.py`.

* All necessary packages and their exact versions are listed in the provided `requirements.txt` file.
* **Essential Libraries:** At minimum, the scripts require `cyvcf2` and `pandas`.
* **Note:** The `requirements.txt` file includes many libraries for generating downstream plots (e.g., Matplotlib, Seaborn). These are **not required** to run the core VCF processing steps defined in this pipeline but are included to reflect the full environment used during development.

### 2. Execution Notes and Performance

* This script is designed as a complete, end-to-end pipeline for VCF processing.

```bash
./DoIt.sh
```

* **Progress Tracking:** It includes numerous `echo` and `print` statements throughout its steps to provide real-time progress and status updates during execution.
* **Performance:** Processing the entire analysis (e.g., 419 samples) typically takes several hours, based on the performance observed on the training server where the script was developed.
* **Running in Background:** To ensure the pipeline runs uninterruptedly until completion, it is recommended to execute it in the background using the `nohup` command, which directs output to a log file (`DoIt.log`):

```bash
nohup ./DoIt.sh > DoIt.log 2>&1 &
```

## üìù Step-by-Step Details

### Cleanup and Setup

The script first cleans up previous results in all output directories and creates a new summary file (`variant_counts.txt`).

### Step 1: PASS Filtering

Uses `awk` with `zcat` and `bgzip` to efficiently filter the input VCF file, retaining the header and only variants where the `FILTER` column (column 7) is exactly `PASS`. 

### Step 2: LiftOver (hg19 to hg38)

Uses **GATK's `LiftoverVcf`** tool, run via Apptainer, to convert coordinates from hg19 (GRCh37) to hg38 (GRCh38). 
* **Rejected Variants:** Variants that fail the conversion are written to the `Rejected` directory.

### Step 3: VEP Annotation

Runs the **Ensembl VEP** for comprehensive annotation.
* **Configuration:** Uses `--everything`, `--offline`, and custom annotations including **SpliceAI**, **REVEL**, **ClinVar**, **CIViC**, and **CancerHotspots** databases to add functional and clinical context.

### Step 4: OncoKB Annotation

This Python script serves as the core clinical annotation engine for the pipeline. It interacts directly with the **OncoKB Precision Oncology Knowledge Base** API to enrich VEP-annotated VCF files with therapeutic, diagnostic, and prognostic information.

#### Key Features

* **Dual Annotation Modes:** Supports both tumor-specific queries (inferred from the filename) for targeted evidence and generic pan-cancer queries for broad analysis.
* **Smart Transcript Prioritization:** Implements a rigorous **3-tier selection logic** to ensure variants are annotated using the clinically relevant transcript (matching TSO500 standards), rather than just the VEP default.
* **Comprehensive Variant Handling:** Processes SNVs, Indels, and Copy Number Alterations (CNVs), with specific support for **Manta** structural variant callers (handling `MantaDUP`, `MantaDEL`, and `MantaINS` correctly).
* **Traceability:** Adds metadata fields (`GENE_EXIST`, `VARIANT_EXIST`) to explicitly track what was found in the database versus what was queried.

#### Logic and Workflow

1.  **Tumor Type Inference**
    * The script parses the input VCF filename against a predefined dictionary (`CANCER_MAP`) to detect the tumor type (e.g., "Lung", "Breast").
    * This ensures OncoKB returns evidence levels specific to that cancer context (e.g., Level 1 evidence for *EGFR* L858R in Lung Cancer vs. Level 3 in other types).
    * *Option:* Use `--tumor_mode=generic` to force a non-specific query ("UNKNOWN" tumor type) for pan-cancer evidence. Based on Oncokb documentation, generic is a better option but TODO I need to compare both results.

2.  **Variant Classification**
    * The script reads the VCF and intelligently classifies each record to determine the correct OncoKB API endpoint:
        * **Mutations (SNV/Indel/INS/BND):** Queries the `/annotate/mutations/byProteinChange` endpoint. This includes Structural Insertions (`MantaINS`) which are treated as mutations to capture protein changes (e.g., Exon 20 insertions).
        * **CNVs (DUP/DEL):** Queries the `/annotate/copyNumberAlterations` endpoint. This specifically targets Amplifications (`MantaDUP`, `GAIN`) and Deletions (`MantaDEL`, `LOSS`).

> **‚ÑπÔ∏è Technical Note: Handling Structural Insertions (`MantaINS`)**
>
> In this pipeline, **Structural Insertions** (`MantaINS`) are intentionally routed to the **Mutation** endpoint (`/annotate/mutations/byProteinChange`) rather than the Copy Number Alteration (CNV) endpoint. This is done for two critical reasons:
>
> 1.  **Clinical Biology:** Unlike simple Duplications (which increase gene dosage), Insertions often alter the internal sequence of the gene (e.g., **EGFR Exon 20 insertions**). These disruptions create specific mutant proteins that require distinct targeted therapies, which are completely different from therapies used for gene amplifications.
> 2.  **API Constraints:** The OncoKB CNV endpoint is strictly typed and **only** accepts `AMPLIFICATION`, `DELETION`, `GAIN`, or `LOSS`. It explicitly rejects `INSERTION`.
>
> By treating `MantaINS` as mutations, the pipeline leverages the Protein Change (HGVSp) calculated by VEP, ensuring that complex, actionable structural mutations are correctly identified and not misclassified as generic "amplifications."

3.  **Transcript Selection Strategy (Crucial Step)**
    To ensure the variant is annotated using the clinically relevant isoform, the script parses the VEP `CSQ` field using a **3-Tier Priority System**:
    * **Tier 1 (Preferred List):** Checks if any transcript in the VEP annotation matches a RefSeq ID (NM_*) found in `TSO500_transcripts_list.txt`. Matches are **version-agnostic** (e.g., `NM_000057.4` in the VCF will match `NM_000057` in the list).
    * **Tier 2 (MANE Select):** If no Tier 1 match is found, it searches for the transcript tagged as **MANE Select** or **MANE Plus Clinical** by Ensembl/NCBI.
    * **Tier 3 (Fallback):** If neither is found, it defaults to the first transcript reported by VEP.

4.  **API Query & Annotation**
    * Constructs a query using the Gene Symbol, Protein Change (converted to 1-letter code, e.g., `P2053L`), and Tumor Type.
    * The JSON response from OncoKB is flattened and written back into the VCF as new `INFO` fields.


### Step 5: VCF2table

This script performs the final step of the pipeline: parsing the fully annotated VCF file and converting it into a structured, analysis-ready CSV table.

Crucially, it implements the **exact same 3-Tier Transcript Selection Logic** as the OncoKB annotator (`oncokb2.0.py`). This ensures data consistency: the transcript displayed in your final table is guaranteed to be the same transcript used to query OncoKB for clinical evidence.

#### Key Features

* **Consistent Prioritization:** Uses the hierarchy `Preferred List > MANE Select > MANE Plus Clinical > Fallback` to extract the most relevant VEP annotation for every variant.
* **Version-Agnostic Matching:** Safely handles RefSeq IDs by stripping version numbers (e.g., matching `NM_004958.4` in the VCF to `NM_004958` in your list).
* **Customizable Columns:** Allows you to define exactly which VEP fields and OncoKB INFO tags appear in the output via external configuration files.
* **Robust Parsing:** Handles complex VEP `CSQ` strings and multi-allelic variants correctly.

#### Logic and Workflow

1.  **Configuration Loading**
    * Reads the list of desired VEP fields from `--vep-fields` (must match the VCF header order).
    * Reads the list of OncoKB tags from `--oncokb-fields`.
    * Loads the preferred transcript list (`--transcripts`), stripping any version numbers to ensure robust matching.

2.  **Variant Iteration**
    * Reads the input VCF line by line.
    * Extracts global `INFO` tags (like OncoKB results) which apply to the variant as a whole.
    * Parses the `CSQ` (Consequence) string, which contains annotations for multiple transcripts.

3.  **Transcript Selection (The Core Logic)**
    For each variant, the script evaluates all available transcript annotations using the following priority:
    * **Tier 1 (Preferred):** Does the annotation contain an NM ID (in `MANE_SELECT`, `MANE_PLUS_CLINICAL`, or `HGVSc`) that matches your `TSO500` list?
    * **Tier 2 (MANE Select):** If not, is it tagged as the *MANE Plus Clinical* transcript?
    * **Tier 3 (MANE Plus Clinical):** If not, is it tagged as *MANE Select*?
    * **Tier 4 (Fallback):** If none of the above, use the first annotation provided by VEP (default behavior).

4.  **Output Generation**
    * Combines the standard VCF columns (`CHROM`, `POS`, `REF`, `ALT`), the selected transcript ID (`NM_Transcript`), the selection method used (for QC), the specific VEP annotation fields for that transcript, and the OncoKB data.
    * Writes this combined record to the CSV file.

‚ùå ***I have left an example of one table in the the folder Output_Results***

## üìù TODO List
- [ ] End to end analysis over the 420 samples again and check we dont miss variants. 
- [ ] Check what variants are rejected by liftover. We shouldn't reject many as all our variants in this step are PASS only.
- [ ] Repeat the analysis twice (generic vs. tumour type) anc check what shows better annotation
- [ ] Validation/test. I need to create a very small VCF with variants that shows all annotation in OncoKB. In a preliminar view, all variants are unkonwn. I need the final table to see is there is non-unknown variants or test with kown variants in a sitetic VCF and see what is going on. For instance I dont know the decistion taken to Handling Structural Insertions is correct. 





